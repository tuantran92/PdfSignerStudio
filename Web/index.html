<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #fafafa;
            user-select: none;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #pagewrap {
            position: relative;
            margin: 24px auto;
            width: fit-content;
            overflow: hidden; /* <-- THÊM DÒNG NÀY */
        }

        /* --- CSS MỚI CHO HIỆU ỨNG CHUYỂN TRANG --- */
        .page-container {
            position: absolute;
            top: 0;
            left: 0;
            background: #fff;
            box-shadow: 0 0 20px rgba(0,0,0,.08);
            transition: opacity 250ms ease-in-out; /* Tốc độ hiệu ứng mờ */
        }

            .page-container.visible {
                opacity: 1;
                z-index: 1; /* Nổi lên trên */
            }

            .page-container.hidden {
                opacity: 0;
                z-index: 0; /* Nằm dưới */
                pointer-events: none; /* Không bắt sự kiện khi đang ẩn */
            }
        /* ----------------------------------------- */

        #pdfCanvas { /* Canvas giờ sẽ nằm trong page-container */
            display: block;
        }

        #overlay {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: auto;
        }

        .box {
            position: absolute;
            border: 2px solid red;
            box-sizing: border-box;
        }

            .box.req {
                border-color: red;
            }

            .box.nreq {
                border-color: #888;
                border-style: dashed;
            }

            .box.sel {
                outline: 2px solid #1976d2;
            }

        .handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #1976d2;
            right: -6px;
            bottom: -6px;
            cursor: nwse-resize;
        }

        .gridbg {
            background-image: linear-gradient(to right, rgba(0,0,0,.06) 1px, transparent 1px), linear-gradient(to bottom, rgba(0,0,0,.06) 1px, transparent 1px);
            background-size: var(--grid) var(--grid), var(--grid) var(--grid);
        }

        /* Templates panel (left) */
        #tplbar {
            position: fixed;
            left: 12px;
            top: 60px;
            width: 200px;
            bottom: 12px;
            background: #fff;
            box-shadow: 0 2px 12px rgba(0,0,0,.15);
            border-radius: 10px;
            padding: 10px;
            overflow: auto;
            z-index: 9999;
            font-family: system-ui,Segoe UI,Roboto,Arial;
            font-size: 12px;
        }

            #tplbar h3 {
                margin: 0;
                font-size: 13px;
            }

        #tplhdr {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .btn-sm {
            font: 12px system-ui,Segoe UI,Roboto,Arial;
            padding: 3px 6px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
        }

            .btn-sm:hover {
                background: #f7faff;
            }

        .tpl {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            cursor: grab;
            background: #fdfdfd;
        }

            .tpl:hover {
                background: #f7faff;
            }

        .tpl-actions {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        /* Thumbnails panel (right) */
        #thumbbar {
            position: fixed;
            right: 12px;
            top: 60px;
            width: 180px;
            bottom: 12px;
            background: #fff;
            box-shadow: 0 2px 12px rgba(0,0,0,.15);
            border-radius: 10px;
            padding: 10px;
            overflow: auto;
            z-index: 9999;
            font-family: system-ui,Segoe UI,Roboto,Arial;
            font-size: 12px;
        }

            #thumbbar h3 {
                margin: 0 0 8px 0;
                font-size: 13px;
            }

        .thumb {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px;
            margin: 8px 0;
            cursor: pointer;
            background: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

            .thumb canvas, .thumb img {
                width: 140px;
                height: auto;
                border: 1px solid #eee;
                border-radius: 4px;
            }

            .thumb .pnum {
                color: #555;
                font-size: 12px;
            }

            .thumb.cur {
                outline: 2px solid #1976d2;
            }

            .thumb:hover {
                background: #f7faff;
            }

        /* Template modal */
        #tplModal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.25);
            z-index: 100000;
        }

        #tplPanel {
            width: 640px;
            max-height: 80vh;
            overflow: auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,.25);
            padding: 16px;
            font: 13px system-ui,Segoe UI,Roboto,Arial;
        }

            #tplPanel h3 {
                margin: 0 0 12px 0;
            }

        #tplForm label {
            display: block;
            margin: 8px 0 4px;
        }

        #tplItemsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px;
        }

            #tplItemsTable th, #tplItemsTable td {
                border: 1px solid #eee;
                padding: 6px;
                text-align: left;
            }

            #tplItemsTable input[type="text"], #tplItemsTable input[type="number"] {
                width: 100%;
                box-sizing: border-box;
            }

        #tplBtns {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }

        /* thẻ template: cho phép đặt icon góc phải */
        .tpl {
            position: relative;
            padding: 8px 56px 8px 8px; /* chừa chỗ cho 2 icon bên phải */
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 6px 0;
            cursor: grab;
            background: #fdfdfd;
        }

        /* nút icon nhỏ ở góc phải */
        .icon-btn {
            position: absolute;
            top: 6px;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            opacity: .85;
            cursor: pointer;
            padding: 0;
        }

            .icon-btn:hover {
                opacity: 1;
                background: #f7faff;
            }

        .icon-edit {
            right: 34px;
        }

        .icon-del {
            right: 6px;
        }

        /* reset button default */
        .icon-btn {
            border: 1px solid #ddd;
        }

            .icon-btn svg {
                width: 14px;
                height: 14px;
                stroke: #333;
            }

        .icon-del svg {
            stroke: #b00020;
        }

        /* lớp hiển thị khung khi đang drag template */
        #ghost {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .ghost-box {
            position: absolute;
            box-sizing: border-box;
            border: 2px dashed #1976d2;
            background: rgba(25,118,210,.08);
            border-radius: 6px;
        }

            .ghost-box > span {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%,-50%);
                font: 12px system-ui,Segoe UI,Roboto,Arial;
                color: #0d47a1;
                background: rgba(255,255,255,.7);
                padding: 1px 6px;
                border-radius: 6px;
                white-space: nowrap;
                max-width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
            }
    </style>
</head>
<body>
    <div id="tplbar">
        <div id="tplhdr">
            <h3>Templates</h3>
            <button id="btnNewTpl" class="btn-sm">New</button>
        </div>
        <div id="tpllist">Loading…</div>
    </div>

    <div id="thumbbar"><h3>Pages</h3><div id="thumblist">Loading…</div></div>

    <div id="container">
        <div id="pagewrap">
        </div>
    </div>

    <div id="tplModal">
        <div id="tplPanel">
            <h3 id="tplTitle">Template</h3>
            <div id="tplForm">
                <label>Template Name</label>
                <input id="tplName" type="text" placeholder="e.g. Director + Accountant" />
                <table id="tplItemsTable">
                    <thead>
                        <tr><th>Name</th><th>W (pt)</th><th>H (pt)</th><th>Req</th><th>dx</th><th>dy</th><th></th></tr>
                    </thead>
                    <tbody id="tplItemsBody"></tbody>
                </table>
                <div style="margin-top:8px">
                    <button id="btnAddItem" class="btn-sm">Add item</button>
                </div>
            </div>
            <div id="tplBtns">
                <button id="btnTplDelete" class="btn-sm" style="margin-right:auto;color:#b00020">Delete</button>
                <button id="btnTplCancel" class="btn-sm">Cancel</button>
                <button id="btnTplSave" class="btn-sm">Save</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const pdfUrl = '__PDF_URL__';
        let pdfDoc = null, pageNum = 1, scale = 1.25;
        let viewport = null; // viewport của trang đang hiển thị

        // --- BIẾN TOÀN CỤC THAY ĐỔI ---
        const pageWrap = document.getElementById('pagewrap');
        let overlay; // Overlay giờ sẽ được gán động
        // -----------------------------

        const container = document.getElementById('container');
        const thumbList = document.getElementById('thumblist');
        let thumbCanvases = [];

        let pageCache = {}; // Cache lưu các trang đã render: {pageNum: {canvas, viewport}}
        let isFlipping = false;
        let flipScrollTarget = null;

        let gridPt = 8, snapTolPx = 5, MIN_GRID_CELLS = 3;
        let currentTplDrag = null, ghostWrap = null;

        function ensureGhost() {
            if (!overlay) return; // Cần có overlay mới tạo ghost được
            if (!ghostWrap || !overlay.contains(ghostWrap)) {
                if (ghostWrap) ghostWrap.remove();
                ghostWrap = document.createElement('div');
                ghostWrap.id = 'ghost';
                overlay.appendChild(ghostWrap);
            }
            ghostWrap.innerHTML = '';
        }
        function clearGhost() { if (ghostWrap) { ghostWrap.remove(); ghostWrap = null; } }
        function drawGhostTemplate(tpl, x, y) {
            if (!tpl || !viewport) return;
            ensureGhost();
            for (const it of tpl.items) {
                const s = snapRectPx(x + ptToPx(it.dx), y + ptToPx(it.dy), ptToPx(it.w), ptToPx(it.h));
                const b = document.createElement('div');
                b.className = 'ghost-box';
                Object.assign(b.style, { left: s.left + 'px', top: s.top + 'px', width: s.width + 'px', height: s.height + 'px' });
                const lbl = document.createElement('span');
                lbl.textContent = it.name ?? 'Signature';
                b.appendChild(lbl);
                ghostWrap.appendChild(b);
            }
        }
        function ptToPx(v) { return v * scale; }
        function pxToPt(v) { return v / scale; }
        function pageHeightPt() { return viewport.height / scale; }
        function gridPx() { return Math.max(4, Math.round(ptToPx(gridPt))); }
        function applyGridBg() { if (overlay) overlay.style.setProperty('--grid', gridPx() + 'px'); }
        function snapValPx(v, candidates) {
            let best = v;
            for (const c of candidates) { if (Math.abs(v - c) <= snapTolPx) { best = c; break; } }
            return best;
        }
        function guideCandidatesPx(includeBoxes = true) {
            const xCands = [], yCands = [];
            if (!overlay) return { xCands, yCands };
            const w = overlay.offsetWidth, h = overlay.offsetHeight;
            xCands.push(0, w / 2, w);
            yCands.push(0, h / 2, h);
            if (includeBoxes) {
                overlay.querySelectorAll('.box').forEach(b => {
                    const x = b.offsetLeft, y = b.offsetTop, bw = b.offsetWidth, bh = b.offsetHeight;
                    xCands.push(x, x + bw / 2, x + bw);
                    yCands.push(y, y + bh / 2, y + bh);
                });
            }
            return { xCands, yCands };
        }
        function snapRectPx(left, top, width, height) {
            const { xCands, yCands } = guideCandidatesPx(true);
            const sx1 = snapValPx(left, xCands), sx2 = snapValPx(left + width, xCands);
            const sy1 = snapValPx(top, yCands), sy2 = snapValPx(top + height, yCands);
            let l = Math.abs(sx1 - left) <= Math.abs(sx2 - (left + width)) ? sx1 : (sx2 - width);
            let t = Math.abs(sy1 - top) <= Math.abs(sy2 - (top + height)) ? sy1 : (sy2 - height);
            return { left: l, top: t, width, height };
        }

        let fields = [], selectedId = null, dragging = null, editingId = null;
        function post(msg) { chrome.webview.postMessage(JSON.stringify(msg)); }

        // ====== LOGIC RENDER VÀ CHUYỂN TRANG MỚI ======

        // 1. Render một trang vào cache, trả về canvas và viewport
        async function renderPageToCache(num) {
            if (pageCache[num]) return pageCache[num];
            const page = await pdfDoc.getPage(num);
            const pageViewport = page.getViewport({ scale });
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = pageViewport.width;
            offscreenCanvas.height = pageViewport.height;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            await page.render({ canvasContext: offscreenCtx, viewport: pageViewport }).promise;
            const cacheEntry = { canvas: offscreenCanvas, viewport: pageViewport };
            pageCache[num] = cacheEntry;
            return cacheEntry;
        }

        // 2. Tải trước các trang liền kề
        function preloadAdjacentPages(num) {
            setTimeout(() => {
                const pagesToLoad = [num - 1, num + 1];
                for (const pageNumToLoad of pagesToLoad) {
                    if (pageNumToLoad > 0 && pageNumToLoad <= pdfDoc.numPages && !pageCache[pageNumToLoad]) {
                        renderPageToCache(pageNumToLoad).catch(err => console.error(`Failed to pre-render page ${pageNumToLoad}`, err));
                    }
                }
            }, 100);
        }

        // 3. Hàm chính để hiển thị trang với hiệu ứng
        async function displayPage(num) {
            const cacheEntry = pageCache[num] || await renderPageToCache(num);
            viewport = cacheEntry.viewport; // Cập nhật viewport toàn cục

            // Tìm page container cũ (nếu có)
            const oldPage = pageWrap.querySelector('.page-container.visible');

            // Tạo page container mới cho trang sắp hiển thị
            const newPage = document.createElement('div');
            newPage.className = 'page-container hidden'; // Bắt đầu ẩn

            // Chuyển canvas từ cache vào
            const pageCanvas = cacheEntry.canvas;
            pageCanvas.id = 'pdfCanvas'; // Gán ID để tương thích
            newPage.appendChild(pageCanvas);

            // Tạo overlay mới hoặc di chuyển overlay cũ vào page container mới
            if (!overlay) { // Lần đầu tiên, tạo mới
                overlay = createOverlay();
            }
            newPage.appendChild(overlay);

            pageWrap.appendChild(newPage);

            // Cập nhật kích thước wrapper
            pageWrap.style.width = viewport.width + 'px';
            pageWrap.style.height = viewport.height + 'px';

            // Cập nhật UI khác
            post({ type: 'meta', numPages: pdfDoc.numPages, page: num });
            markCurrentThumb(num);
            applyGridBg();
            redraw(); // Vẽ lại các box trên overlay mới

            // --- Kích hoạt hiệu ứng ---
            // Dùng setTimeout để đảm bảo trình duyệt đã render newPage trước khi đổi class
            setTimeout(() => {
                if (oldPage) {
                    oldPage.classList.remove('visible');
                    oldPage.classList.add('hidden');
                }
                newPage.classList.add('visible');
                newPage.classList.remove('hidden');

                // Dọn dẹp page cũ sau khi hiệu ứng kết thúc
                if (oldPage) {
                    setTimeout(() => oldPage.remove(), 250); // 250ms = thời gian transition
                }
            }, 10);

            // Đặt lại scroll
            if (flipScrollTarget === 'top') container.scrollTop = 1;
            else if (flipScrollTarget === 'bottom') container.scrollTop = Math.max(0, container.scrollHeight - container.clientHeight - 1);
            flipScrollTarget = null;

            preloadAdjacentPages(num);
        }

        // 4. Hàm điều hướng chính
        window.setPage = async function (num) {
            if (isFlipping || num === pageNum) return;
            isFlipping = true;
            pageNum = Math.min(Math.max(1, num), pdfDoc.numPages);
            await displayPage(pageNum);
            isFlipping = false;
        };

        // 5. Hàm tạo Overlay và gắn các event listener (CHỈ CHẠY 1 LẦN)
        function createOverlay() {
            const ov = document.createElement('div');
            ov.id = 'overlay';
            ov.tabIndex = 0;
            ov.className = 'gridbg';

            // Gắn tất cả các event listener vào đây
            ov.addEventListener('mousedown', handleMouseDown);
            ov.addEventListener('mousemove', handleMouseMove);
            ov.addEventListener('keydown', handleKeyDown);
            ov.addEventListener('dblclick', handleDoubleClick);
            ['dragenter', 'dragover'].forEach(type => ov.addEventListener(type, handleEnterOver));
            ov.addEventListener('drop', handleDrop);
            ov.addEventListener('dragleave', handleLeave);
            ov.addEventListener('wheel', handleWheel, { passive: false });

            return ov;
        }

        // ====== Thumbnails ======
        async function buildThumbs() {
            thumbList.innerHTML = '';
            thumbCanvases = [];
            const desiredWidth = 140;

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const vp0 = page.getViewport({ scale: 1 });
                const scaleT = desiredWidth / vp0.width;
                const vp = page.getViewport({ scale: scaleT });

                const cv = document.createElement('canvas');
                cv.width = vp.width; cv.height = vp.height;
                const cctx = cv.getContext('2d');
                cctx.fillStyle = 'white'; cctx.fillRect(0, 0, cv.width, cv.height);
                await page.render({ canvasContext: cctx, viewport: vp }).promise;

                const item = document.createElement('div');
                item.className = 'thumb'; item.dataset.page = i;
                item.appendChild(cv);

                const pspan = document.createElement('div');
                pspan.className = 'pnum'; pspan.textContent = `Page ${i}`;
                item.appendChild(pspan);

                item.addEventListener('click', () => { flipScrollTarget = 'top'; window.setPage(i); });
                thumbList.appendChild(item);
                thumbCanvases.push(cv);
            }
            markCurrentThumb(pageNum);
        }
        function markCurrentThumb(n) {
            document.querySelectorAll('.thumb').forEach(el => el.classList.remove('cur'));
            const el = document.querySelector(`.thumb[data-page="${n}"]`);
            if (el) {
                el.classList.add('cur');
                if (el.scrollIntoView) el.scrollIntoView({ block: 'nearest' });
            }
        }

        // ====== Inline rename ======
        function beginEditName(id) {
            const f = fields.find(t => t.id === id); if (!f) return;
            if (editingId && document.getElementById('nameEditor')) {
                document.getElementById('nameEditor').remove();
                editingId = null;
            }
            const box = overlay.querySelector(`.box[data-id="${id}"]`); if (!box) return;

            const cx = box.offsetLeft + box.offsetWidth / 2, cy = box.offsetTop + box.offsetHeight / 2;
            const w = Math.max(60, Math.min(260, box.offsetWidth - 12));
            const input = document.createElement('input');
            input.id = 'nameEditor'; input.type = 'text'; input.value = f.name;
            Object.assign(input.style, {
                position: 'absolute', left: cx + 'px', top: cy + 'px', transform: 'translate(-50%,-50%)',
                width: w + 'px', padding: '4px 8px', fontFamily: 'system-ui,Segoe UI,Roboto,Arial',
                fontSize: '12px', background: '#fff', border: '1px solid #1976d2', borderRadius: '8px',
                boxShadow: '0 2px 8px rgba(0,0,0,.12)', zIndex: 2147483647
            });
            overlay.appendChild(input);
            editingId = id; input.focus(); input.select();

            function commit() {
                if (!document.getElementById('nameEditor')) return;
                const newName = input.value.trim();
                input.remove(); editingId = null;
                if (newName && newName !== f.name) {
                    post({ type: 'renameField', id: f.id, name: newName, page: pageNum });
                } else { redraw(); }
            }
            function cancel() { if (document.getElementById('nameEditor')) { input.remove(); editingId = null; redraw(); } }
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                if (e.key === 'Escape') { e.preventDefault(); cancel(); }
                e.stopPropagation();
            });
            input.addEventListener('blur', () => commit());
        }

        // ====== Redraw overlay boxes ======
        function redraw() {
            if (!overlay || !viewport) return;
            overlay.innerHTML = '';
            ghostWrap = null;

            const Hpt = pageHeightPt();
            overlay.style.width = viewport.width + 'px';
            overlay.style.height = viewport.height + 'px';

            fields.forEach(f => {
                const div = document.createElement('div');
                div.className = 'box ' + (f.required ? 'req' : 'nreq') + (f.id === selectedId ? ' sel' : '');
                const xpx = ptToPx(f.x), wpx = ptToPx(f.w), hpx = ptToPx(f.h);
                const ypx = ptToPx(Hpt - f.y - f.h);
                Object.assign(div.style, { left: xpx + 'px', top: ypx + 'px', width: wpx + 'px', height: hpx + 'px' });
                div.title = f.name; div.dataset.id = f.id;

                const lbl = document.createElement('span');
                lbl.textContent = f.name;
                Object.assign(lbl.style, {
                    position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%,-50%)', padding: '2px 6px',
                    fontFamily: 'system-ui,Segoe UI,Roboto,Arial', fontSize: '12px', background: 'rgba(255,255,255,.7)',
                    borderRadius: '6px', pointerEvents: 'none', maxWidth: '100%', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis'
                });
                div.appendChild(lbl);

                if (f.id === selectedId) {
                    const h = document.createElement('div');
                    h.className = 'handle'; h.dataset.id = f.id; div.appendChild(h);
                }
                overlay.appendChild(div);
            });
            overlay.focus();
        }

        // ====== TÁCH CÁC HÀM XỬ LÝ EVENT RA RIÊNG ======
        function handleMouseDown(e) {
            if (editingId) return;
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const t = e.target;
            if (t.classList.contains('handle')) {
                selectedId = t.dataset.id;
                const f = fields.find(i => i.id === selectedId); if (!f) return;
                dragging = { mode: 'resize', sx: x, sy: y, startRect: { ...f } };
                overlay.focus(); e.preventDefault(); return;
            }
            const box = t.closest && t.closest('.box');
            if (box) {
                selectedId = box.dataset.id;
                const f = fields.find(i => i.id === selectedId);
                dragging = { mode: 'move', sx: x, sy: y, startRect: { ...f } };
                redraw(); overlay.focus(); e.preventDefault(); return;
            }
            dragging = { mode: 'draw', sx: x, sy: y, startRect: null, moved: false };
            const draft = document.createElement('div');
            draft.className = 'box req';
            Object.assign(draft.style, { left: x + 'px', top: y + 'px', width: '0px', height: '0px' });
            draft.id = 'draft';
            overlay.appendChild(draft); overlay.focus();
        }

        function handleMouseMove(e) {
            if (!dragging) return;
            const rect = overlay.getBoundingClientRect();
            let x = e.clientX - rect.left, y = e.clientY - rect.top;

            if (dragging.mode === 'draw') {
                const draft = document.getElementById('draft');
                if (!draft) return;
                let left = Math.min(dragging.sx, x), top = Math.min(dragging.sy, y);
                let w = Math.abs(x - dragging.sx), h = Math.abs(y - dragging.sy);
                dragging.moved ||= (w > 2 || h > 2);
                const s = snapRectPx(left, top, w, h);
                Object.assign(draft.style, { left: s.left + 'px', top: s.top + 'px', width: s.width + 'px', height: s.height + 'px' });
                return;
            }
            const f0 = dragging.startRect;
            if (dragging.mode === 'move') {
                const dx = x - dragging.sx, dy = y - dragging.sy;
                const nxpx = ptToPx(f0.x) + dx, nypx = ptToPx(pageHeightPt() - f0.y - f0.h) + dy;
                const s = snapRectPx(nxpx, nypx, ptToPx(f0.w), ptToPx(f0.h));
                const f = fields.find(t => t.id === selectedId);
                if (f) { f.x = pxToPt(s.left); f.y = pageHeightPt() - pxToPt(s.top) - f.h; redraw(); }
                return;
            }
            if (dragging.mode === 'resize') {
                const dx = x - dragging.sx, dy = y - dragging.sy;
                let wpx = Math.max(1, ptToPx(f0.w) + dx), hpx = Math.max(1, ptToPx(f0.h) + dy);
                const s = snapRectPx(ptToPx(f0.x), ptToPx(pageHeightPt() - f0.y - f0.h), wpx, hpx);
                const f = fields.find(t => t.id === selectedId);
                if (f) { f.w = pxToPt(s.width); f.h = pxToPt(s.height); redraw(); }
                return;
            }
        }

        window.addEventListener('mouseup', e => {
            if (!dragging) return;
            if (dragging.mode === 'draw') {
                const draft = document.getElementById('draft');
                if (draft) {
                    const xpx = parseFloat(draft.style.left), ypx = parseFloat(draft.style.top);
                    const wpx = parseFloat(draft.style.width), hpx = parseFloat(draft.style.height);
                    const minPx = MIN_GRID_CELLS * gridPx();
                    if (!dragging.moved || wpx < minPx || hpx < minPx) { draft.remove(); dragging = null; return; }
                    draft.remove();
                    const Hpt = pageHeightPt();
                    const xpt = pxToPt(xpx), wpt = pxToPt(wpx), hpt = pxToPt(hpx);
                    const ypt = Hpt - pxToPt(ypx) - hpt;
                    post({ type: 'addField', page: pageNum, rect: { x: xpt, y: ypt, w: wpt, h: hpt, required: true } });
                }
                dragging = null; return;
            }
            const f = fields.find(t => t.id === selectedId);
            if (f) post({ type: 'updateField', id: f.id, page: pageNum, rect: { x: f.x, y: f.y, w: f.w, h: f.h } });
            dragging = null;
        });

        function handleKeyDown(e) {
            if (editingId) return;
            if (e.key === 'PageDown' && pageNum < pdfDoc.numPages) {
                flipScrollTarget = 'top'; window.setPage(pageNum + 1); e.preventDefault(); return;
            }
            if (e.key === 'PageUp' && pageNum > 1) {
                flipScrollTarget = 'bottom'; window.setPage(pageNum - 1); e.preventDefault(); return;
            }
            const f = fields.find(t => t.id === selectedId); if (!f) return;
            const stepPt = e.shiftKey ? 5 : 1;
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                if (e.key === 'ArrowLeft') f.x -= stepPt; if (e.key === 'ArrowRight') f.x += stepPt;
                if (e.key === 'ArrowUp') f.y += stepPt; if (e.key === 'ArrowDown') f.y -= stepPt;
                redraw();
                post({ type: 'updateField', id: f.id, page: pageNum, rect: { x: f.x, y: f.y, w: f.w, h: f.h } });
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r') { post({ type: 'toggleRequired', id: f.id, page: pageNum }); e.preventDefault(); }
            if (e.key === 'Delete') { post({ type: 'deleteField', id: f.id, page: pageNum }); e.preventDefault(); }
            if (e.key === 'Enter' || e.key === 'F2') { beginEditName(f.id); e.preventDefault(); }
        }
        function handleDoubleClick(e) {
            const box = e.target.closest && e.target.closest('.box'); if (!box) return;
            const id = box.dataset.id; if (!id) return;
            e.preventDefault(); e.stopPropagation(); beginEditName(id);
        }

        // ====== Template bar (drag & drop + CRUD) ======
        let templatesUi = [];
        function renderTplBar() {
            const list = document.getElementById('tpllist'); list.innerHTML = '';
            const pencilSvg = `<svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M12 20h9" /><path d="M16.5 3.5l4 4L7 21H3v-4L16.5 3.5z" /></svg>`;
            const trashSvg = `<svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M3 6h18" /><path d="M8 6V4h8v2" /><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" /><path d="M10 11v6M14 11v6" /></svg>`;
            const esc = s => (s ?? '').replace(/[&<>"]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[m]));

            templatesUi.forEach(t => {
                const d = document.createElement('div'); d.className = 'tpl'; d.draggable = true;
                d.innerHTML = `<div class="tpl-name">${esc(t.name)}</div><button class="icon-btn icon-edit" title="Edit" aria-label="Edit" type="button">${pencilSvg}</button><button class="icon-btn icon-del"  title="Delete" aria-label="Delete" type="button">${trashSvg}</button>`;
                d.addEventListener('dragstart', ev => {
                    currentTplDrag = t; ev.dataTransfer.effectAllowed = 'copy';
                    ev.dataTransfer.setData('application/json', JSON.stringify(t));
                    ev.dataTransfer.setData('text/plain', '__TPL__' + (t.name || ''));
                    const img = new Image(); img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
                    ev.dataTransfer.setDragImage(img, 0, 0);
                });
                d.addEventListener('dragend', () => { currentTplDrag = null; clearGhost(); });
                const btnEdit = d.querySelector('.icon-edit');
                btnEdit.addEventListener('mousedown', e => e.stopPropagation());
                btnEdit.addEventListener('click', ev => { ev.stopPropagation(); ev.preventDefault(); openTplEditor(structuredClone(t)); });
                const btnDel = d.querySelector('.icon-del');
                btnDel.addEventListener('mousedown', e => e.stopPropagation());
                btnDel.addEventListener('click', ev => { ev.stopPropagation(); ev.preventDefault(); if (confirm(`Delete template "${t.name}"?`)) post({ type: 'deleteTemplate', name: t.name }); });
                list.appendChild(d);
            });
        }
        function findTemplateByName(name) { return templatesUi.find(t => t.name === name) || null; }
        function getTplFromDT(dt) {
            let data = dt.getData('application/json'); if (data) { try { return JSON.parse(data); } catch { } }
            let txt = dt.getData('text/plain'); if (txt && txt.startsWith('__TPL__')) return findTemplateByName(txt.slice(7)); return null;
        }
        function handleEnterOver(e) {
            const dt = e.dataTransfer; const tpl = currentTplDrag || getTplFromDT(dt); if (!tpl) return;
            e.preventDefault(); dt.dropEffect = 'copy'; currentTplDrag = tpl;
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            drawGhostTemplate(tpl, x, y);
        }
        function handleDrop(e) {
            e.preventDefault();
            let tpl = currentTplDrag || getTplFromDT(e.dataTransfer); if (!tpl) { clearGhost(); currentTplDrag = null; return; }
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const Hpt = pageHeightPt();
            for (const it of tpl.items) {
                const s = snapRectPx(x + ptToPx(it.dx), y + ptToPx(it.dy), ptToPx(it.w), ptToPx(it.h));
                const xpt = pxToPt(s.left), ypt = Hpt - pxToPt(s.top) - it.h;
                post({ type: 'addField', page: pageNum, name: it.name, rect: { x: xpt, y: ypt, w: it.w, h: it.h, required: !!it.required } });
            }
            clearGhost(); currentTplDrag = null;
        }
        function handleLeave(e) {
            if (!e.currentTarget.contains(e.relatedTarget)) {
                clearGhost();
            }
        }

        document.addEventListener('dragend', () => { clearGhost(); currentTplDrag = null; });

        const btnNewTpl = document.getElementById('btnNewTpl');
        const tplModal = document.getElementById('tplModal');
        const tplTitle = document.getElementById('tplTitle');
        const tplName = document.getElementById('tplName');
        const tplItemsBody = document.getElementById('tplItemsBody');
        const btnAddItem = document.getElementById('btnAddItem');
        const btnTplSave = document.getElementById('btnTplSave');
        const btnTplCancel = document.getElementById('btnTplCancel');
        const btnTplDelete = document.getElementById('btnTplDelete');
        let editingTemplate = null;
        function openTplEditor(tpl) {
            editingTemplate = tpl || { name: '', items: [] };
            tplTitle.textContent = editingTemplate.name ? `Edit: ${editingTemplate.name}` : 'New Template';
            tplName.value = editingTemplate.name || ''; tplItemsBody.innerHTML = '';
            (editingTemplate.items || []).forEach(addTplItemRow);
            tplModal.style.display = 'flex';
            btnTplDelete.style.display = editingTemplate && templatesUi.some(x => x.name === editingTemplate.name) ? 'inline-block' : 'none';
        }
        function closeTplEditor() { tplModal.style.display = 'none'; editingTemplate = null; }
        function addTplItemRow(item) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td><input type="text" value="${item?.name ?? 'Signature'}" /></td><td><input type="number" step="0.5" value="${item?.w ?? 120}"/></td><td><input type="number" step="0.5" value="${item?.h ?? 60}"/></td><td style="text-align:center"><input type="checkbox" ${item?.required !== false ? 'checked' : ''}/></td><td><input type="number" step="0.5" value="${item?.dx ?? 0}"/></td><td><input type="number" step="0.5" value="${item?.dy ?? 0}"/></td><td><button class="btn-sm">✕</button></td>`;
            tr.querySelector('button').addEventListener('click', () => tr.remove()); tplItemsBody.appendChild(tr);
        }
        function collectTplItems() {
            const rows = Array.from(tplItemsBody.querySelectorAll('tr'));
            return rows.map(r => {
                const [nameI, wI, hI, reqI, dxI, dyI] = r.querySelectorAll('input');
                return { name: nameI.value.trim() || 'Signature', w: parseFloat(wI.value) || 1, h: parseFloat(hI.value) || 1, required: !!reqI.checked, dx: parseFloat(dxI.value) || 0, dy: parseFloat(dyI.value) || 0 };
            });
        }
        btnNewTpl.addEventListener('click', () => openTplEditor({ name: '', items: [] }));
        btnAddItem.addEventListener('click', (e) => { e.preventDefault(); addTplItemRow({}); });
        btnTplCancel.addEventListener('click', (e) => { e.preventDefault(); closeTplEditor(); });
        btnTplSave.addEventListener('click', (e) => {
            e.preventDefault(); const name = tplName.value.trim(); if (!name) { alert('Template name is required'); return; }
            const items = collectTplItems(); if (!items.length) { alert('Add at least one item'); return; }
            post({ type: 'saveTemplate', template: { name, items } }); closeTplEditor();
        });
        btnTplDelete.addEventListener('click', (e) => {
            e.preventDefault(); const name = tplName.value.trim(); if (!name) return;
            if (confirm(`Delete template "${name}"?`)) { post({ type: 'deleteTemplate', name }); closeTplEditor(); }
        });
        tplModal.addEventListener('click', (e) => { if (e.target === tplModal) closeTplEditor(); });

        // ====== Page flip by mouse wheel ======
        function handleWheel(e) {
            if (!pdfDoc || editingId || dragging || isFlipping) return;
            const canScroll = (container.scrollHeight - container.clientHeight) > 2;
            const nearTop = !canScroll || container.scrollTop <= 0;
            const nearBottom = !canScroll || (container.scrollTop + container.clientHeight >= container.scrollHeight - 2);
            if (e.deltaY > 0 && nearBottom && pageNum < pdfDoc.numPages) {
                e.preventDefault(); flipScrollTarget = 'top'; window.setPage(pageNum + 1);
            } else if (e.deltaY < 0 && nearTop && pageNum > 1) {
                e.preventDefault(); flipScrollTarget = 'bottom'; window.setPage(pageNum - 1);
            }
        }
        container.addEventListener('wheel', handleWheel, { passive: false });

        // ====== API host → webview ======
        window.setFields = function (list) { fields = list || []; if (selectedId && !fields.some(f => f.id === selectedId)) selectedId = null; redraw(); if (overlay) overlay.focus(); };
        window.zoomIn = async function () {
            scale = Math.min(scale + 0.25, 4); pageCache = {}; // Xóa cache khi zoom
            pageWrap.innerHTML = ''; // Xóa các page container cũ
            await displayPage(pageNum);
        };
        window.zoomOut = async function () {
            scale = Math.max(scale - 0.25, 0.5); pageCache = {}; // Xóa cache khi zoom
            pageWrap.innerHTML = ''; // Xóa các page container cũ
            await displayPage(pageNum);
        };
        window.setTemplates = function (list) { templatesUi = list || []; renderTplBar(); };

        // ====== Boot ======
        async function main() {
            pdfDoc = await pdfjsLib.getDocument(pdfUrl).promise;
            renderTplBar(); // Gọi lại hàm render template
            await buildThumbs();
            await displayPage(pageNum);
        }
        main();

    </script>
</body>
</html>