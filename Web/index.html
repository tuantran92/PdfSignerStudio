<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        /* Thêm vào trong thẻ <style> của file index.html */

        body {
            background-color: #f0f2f5; /* Màu nền dịu mắt hơn */
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #fafafa;
            user-select: none;
            font-family: system-ui,Segoe UI,Roboto,Arial;
        }

        #container {
            position: relative; /* Giữ nguyên để tạo context */
            z-index: 1; /* << THÊM DÒNG NÀY */

            width: 100%;
            margin-top: 88px; /* 78px cho menu + 10px lề */
            height: calc(100% - 88px); /* Phải cập nhật chiều cao tương ứng */

            padding-top: 0; /* Bỏ padding cũ */
            overflow: auto;
            box-sizing: border-box;
        }

        #pagewrap {
            position: relative;
            margin: 0 auto 24px auto;
            width: fit-content;
            overflow: hidden;
            position: relative;
            /* Đổ bóng cho trang giấy, tạo cảm giác nổi khối */
            box-shadow: 0 4px 12px rgba(0,0,0,.1);
        }

        #top-toolbar {
            position: fixed;
            top: 10px; /* will be updated by JS */
            left: 0; /* will be updated by JS */
            transform: translateX(-50%);
            z-index: 10000;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,.15);
            padding: 6px;
            display: none;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(0,0,0,0.08);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background-color: #e0e0e0;
            margin: 0 4px;
        }

        .btn-tool {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
            border: none;
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

            .btn-tool:hover {
                background-color: #e8e8e8;
            }

            .btn-tool svg {
                width: 20px;
                height: 20px;
                stroke-width: 1.5;
                color: #333;
            }

        .page-container {
            position: absolute;
            top: 0;
            left: 0;
            background: #fff;
            box-shadow: 0 0 20px rgba(0,0,0,.08);
            transition: opacity 250ms ease-in-out;
        }

            .page-container.visible {
                opacity: 1;
                z-index: 1;
            }

            .page-container.hidden {
                opacity: 0;
                z-index: 0;
                pointer-events: none;
            }

        #pdfCanvas {
            display: block;
        }

        #overlay {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: auto;
        }

        .box {
            position: absolute;
            border: 2px solid red;
            box-sizing: border-box;
            scroll-margin-top: 100px;
            scroll-margin-bottom: 100px;
        }

            .box.req {
                border-color: red;
            }

            .box.nreq {
                border-color: #888;
                border-style: dashed;
            }

            .box.sel {
                outline: 2px solid #1976d2;
                z-index: 2;
            }

        .handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #1976d2;
            border: 2px solid #fff;
            box-sizing: border-box;
            border-radius: 3px;
        }

            .handle.tl {
                left: -6px;
                top: -6px;
                cursor: nwse-resize;
            }

            .handle.tr {
                right: -6px;
                top: -6px;
                cursor: nesw-resize;
            }

            .handle.bl {
                left: -6px;
                bottom: -6px;
                cursor: nesw-resize;
            }

            .handle.br {
                right: -6px;
                bottom: -6px;
                cursor: nwse-resize;
            }

        .gridbg {
            background: none !important;
        }

        #left-panel {
            position: fixed;
            left: 12px;
            top: 88px;
            bottom: 12px;
            width: 200px;
            background: #fff;
            box-shadow: 0 2px 12px rgba(0,0,0,.15);
            border-radius: 10px;
            padding: 10px;
            z-index: 9999;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            transition: box-shadow 0.2s ease-out;
        }

            #left-panel.dragover {
                box-shadow: 0 0 0 3px #1976d2, 0 2px 12px rgba(0,0,0,.25);
            }

        #left-panel-main-content {
            overflow-y: auto;
            flex-grow: 1;
        }

        #left-panel h3 {
            margin: 0;
            font-size: 13px;
        }

        .panel-divider {
            border: none;
            border-top: 1px solid #eee;
            margin: 12px 0;
        }

        #addedfieldslist .field-item {
            padding: 4px 2px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

            #addedfieldslist .field-item:hover {
                background-color: #f0f6ff;
            }

            #addedfieldslist .field-item:last-child {
                border-bottom: none;
            }

        #addedfieldslist .empty-state {
            color: #888;
            padding-top: 8px;
        }

        #selection-actions {
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid #eee;
            flex-shrink: 0;
        }

        #tplhdr {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .btn-sm {
            font: 12px system-ui,Segoe UI,Roboto,Arial;
            padding: 3px 6px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            cursor: pointer;
        }

            .btn-sm:hover {
                background: #f7faff;
            }

        .tpl {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            cursor: grab;
            background: #fdfdfd;
        }

            .tpl:hover {
                background: #f7faff;
            }

        #thumbbar {
            position: fixed;
            right: 12px;
            top: 88px;
            width: 180px;
            bottom: 12px;
            background: #fff;
            box-shadow: 0 2px 12px rgba(0,0,0,.15);
            border-radius: 10px;
            padding: 10px;
            overflow: auto;
            z-index: 9999;
            font-size: 12px;
        }

            #thumbbar h3 {
                margin: 0 0 8px 0;
                font-size: 13px;
            }

        .thumb {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px;
            margin: 8px 0;
            cursor: pointer;
            background: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

            .thumb canvas, .thumb img {
                width: 140px;
                height: auto;
                border: 1px solid #eee;
                border-radius: 4px;
            }

            .thumb .pnum {
                color: #555;
                font-size: 12px;
            }

            .thumb.cur {
                outline: 2px solid #1976d2;
            }

            .thumb:hover {
                background: #f7faff;
            }

        #tplModal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.25);
            z-index: 100000;
        }

        #tplPanel {
            width: 640px;
            max-height: 80vh;
            overflow: auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,.25);
            padding: 16px;
            font: 13px system-ui,Segoe UI,Roboto,Arial;
        }

            #tplPanel h3 {
                margin: 0 0 12px 0;
            }

        #tplForm label {
            display: block;
            margin: 8px 0 4px;
        }

        #tplItemsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px;
        }

            #tplItemsTable th, #tplItemsTable td {
                border: 1px solid #eee;
                padding: 6px;
                text-align: left;
            }

            #tplItemsTable input[type="text"], #tplItemsTable input[type="number"] {
                width: 100%;
                box-sizing: border-box;
            }

        #tplBtns {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }

        .tpl {
            position: relative;
            padding: 8px 56px 8px 8px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 6px 0;
            cursor: grab;
            background: #fdfdfd;
        }

        .icon-btn {
            position: absolute;
            top: 6px;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
            opacity: .85;
            cursor: pointer;
            padding: 0;
        }

            .icon-btn:hover {
                opacity: 1;
                background: #f7faff;
            }

        .icon-edit {
            right: 34px;
        }

        .icon-del {
            right: 6px;
        }

        .icon-btn {
            border: 1px solid #ddd;
        }

            .icon-btn svg {
                width: 14px;
                height: 14px;
                stroke: #333;
            }

        .icon-del svg {
            stroke: #b00020;
        }

        #ghost {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .ghost-box {
            position: absolute;
            box-sizing: border-box;
            border: 2px dashed #1976d2;
            background: rgba(25,118,210,.08);
            border-radius: 6px;
        }

            .ghost-box > span {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%,-50%);
                font: 12px system-ui,Segoe UI,Roboto,Arial;
                color: #0d47a1;
                background: rgba(255,255,255,.7);
                padding: 1px 6px;
                border-radius: 6px;
                white-space: nowrap;
                max-width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
            }

        /* === Minimal Grid/Ruler overlays === */
        #grid-overlay, #ruler-top, #ruler-left {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        #grid-overlay {
            inset: 0;
        }

        #ruler-top {
            left: 0;
            top: 0;
            height: 24px;
            width: 100%;
            background: repeating-linear-gradient(90deg, rgba(0,0,0,.15) 0, rgba(0,0,0,.15) 1px, transparent 1px, transparent 10px);
            display: none;
        }

        #ruler-left {
            top: 0;
            left: 0;
            width: 24px;
            height: 100%;
            background: repeating-linear-gradient(180deg, rgba(0,0,0,.15) 0, rgba(0,0,0,.15) 1px, transparent 1px, transparent 10px);
            display: none;
        }

        #btn-undo, #btn-redo {
            display: none !important;
        }

        /* === Professional theme polish (added) === */
        :root {
            --bg: #f6f7fb;
            --panel: #ffffff;
            --text: #0f172a;
            --border: rgba(0,0,0,.12);
            --shadow: 0 8px 28px rgba(0,0,0,.14);
            --accent: #2563eb;
        }

        }

        html, body {
            background: var(--bg);
            color: var(--text);
        }

        #top-toolbar {
            background: color-mix(in oklab, var(--panel) 92%, transparent);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            gap: 6px;
        }

        .btn-tool {
            border-radius: 10px;
            transition: transform .12s ease, background-color .12s ease;
        }

            .btn-tool:hover {
                background: rgba(0,0,0,.08);
                transform: translateY(-1px);
            }

            .btn-tool:active {
                transform: translateY(0);
            }

            .btn-tool svg {
                color: var(--text);
            }

        #left-panel, #thumbbar {
            background: var(--panel);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .thumb {
            border-color: var(--border);
        }

            .thumb.cur {
                outline: 2px solid var(--accent);
            }

            .tpl:hover, .thumb:hover {
                background: color-mix(in oklab, var(--panel) 96%, var(--accent) 4%);
            }

        .box > span {
            font-weight: 600;
            letter-spacing: .1px;
            border: 1px solid var(--border);
            backdrop-filter: blur(2px);
        }

        .box.req {
            border-color: var(--accent);
        }

        .box.sel {
            outline-color: var(--accent);
        }

        .handle {
            background: var(--accent);
        }

        .page-container {
            transition: opacity .25s ease;
        }
    </style>
</head>
<body>
    <div id="top-toolbar">
        <button title="Match Width" class="btn-tool" id="btn-match-w"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12H3M21 3H3M21 21H3M12 21V3" /></svg></button>
        <button title="Match Height" class="btn-tool" id="btn-match-h"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21V3M21 12H3M21 3H3M21 21H3" /></svg></button>
        <button title="Match Size" class="btn-tool" id="btn-match-wh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" /></svg></button>
        <button title="Undo" class="btn-tool" id="btn-undo"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6" /><path d="M21 13a9 9 0 0 0-9-9 9 9 0 0 0-9 9" /></svg></button>
        <button title="Redo" class="btn-tool" id="btn-redo"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6" /><path d="M3 13a9 9 0 0 1 9-9 9 9 0 0 1 9 9" /></svg></button>
        <div class="toolbar-divider"></div>
        <button title="Align Left" class="btn-tool" id="btn-align-left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="21" x2="4" y2="3" /><rect x="8" y="6" width="8" height="6" rx="1" /><rect x="8" y="14" width="12" height="6" rx="1" /></svg></button>
        <button title="Align Horizontal Center" class="btn-tool" id="btn-align-h-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="21" x2="12" y2="3" /><rect x="6" y="6" width="12" height="6" rx="1" /><rect x="8" y="14" width="8" height="6" rx="1" /></svg></button>
        <button title="Align Right" class="btn-tool" id="btn-align-right"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="20" y1="21" x2="20" y2="3" /><rect x="8" y="6" width="8" height="6" rx="1" /><rect x="4" y="14" width="12" height="6" rx="1" /></svg></button>
        <div class="toolbar-divider"></div>
        <button title="Align Top" class="btn-tool" id="btn-align-top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="4" x2="21" y2="4" /><rect x="6" y="8" width="6" height="8" rx="1" /><rect x="14" y="8" width="6" height="12" rx="1" /></svg></button>
        <button title="Align Vertical Center" class="btn-tool" id="btn-align-v-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12" /><rect x="6" y="6" width="6" height="12" rx="1" /><rect x="14" y="8" width="6" height="8" rx="1" /></svg></button>
        <button title="Align Bottom" class="btn-tool" id="btn-align-bottom"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="20" x2="21" y2="20" /><rect x="6" y="4" width="6" height="12" rx="1" /><rect x="14" y="8" width="6" height="8" rx="1" /></svg></button>
        <div class="toolbar-divider"></div>
        <button title="Distribute Horizontally" class="btn-tool" id="btn-dist-h"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="12" x2="20" y2="12" /><rect x="6" y="5" width="4" height="14" rx="1" /><rect x="14" y="5" width="4" height="14" rx="1" /></svg></button>
        <button title="Distribute Vertically" class="btn-tool" id="btn-dist-v"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="4" x2="12" y2="20" /><rect x="5" y="6" width="14" height="4" rx="1" /><rect x="5" y="14" width="14" height="4" rx="1" /></svg></button>
    </div>

    <div id="left-panel">
        <div id="left-panel-main-content">
            <div id="tplhdr">
                <h3>Templates</h3>
                <button id="btnNewTpl" class="btn-sm">New</button>
            </div>
            <div id="tpllist">Loading…</div>
            <hr class="panel-divider">
            <h3>Added Fields</h3>
            <div id="addedfieldslist">
            </div>
        </div>
        <div id="selection-actions" style="display: none;">
            <button id="btnCreateFromSelection" class="btn-sm" style="width: 100%; padding: 8px;">Create Template from Selection</button>
        </div>
    </div>

    <div id="thumbbar"><h3>Pages</h3><div id="thumblist">Loading…</div></div>

    <div id="container">
        <div id="pagewrap">
            <canvas id="grid-overlay"></canvas>
            <div id="ruler-top"></div>
            <div id="ruler-left"></div>

        </div>
    </div>

    <div id="tplModal">
        <div id="tplPanel">
            <h3 id="tplTitle">Template</h3>
            <div id="tplForm">
                <label>Template Name</label>
                <input id="tplName" type="text" placeholder="e.g. Director + Accountant" />
                <table id="tplItemsTable">
                    <thead>
                        <tr><th>Name</th><th>W (pt)</th><th>H (pt)</th><th>Req</th><th>dx</th><th>dy</th><th></th></tr>
                    </thead>
                    <tbody id="tplItemsBody"></tbody>
                </table>
                <div style="margin-top:8px">
                    <button id="btnAddItem" class="btn-sm">Add item</button>
                </div>
            </div>
            <div id="tplBtns">
                <button id="btnTplDelete" class="btn-sm" style="margin-right:auto;color:#b00020">Delete</button>
                <button id="btnTplCancel" class="btn-sm">Cancel</button>
                <button id="btnTplSave" class="btn-sm">Save</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // *** FIX: Removed pdfUrl constant. It will be passed by C#. ***
        let pdfDoc = null, pageNum = 1, scale = 1.25;
        let viewport = null;

        const pageWrap = document.getElementById('pagewrap');
        let overlay;

        const container = document.getElementById('container');
        const thumbList = document.getElementById('thumblist');
        let thumbCanvases = [];

        let pageCache = {};
        let isFlipping = false;
        let flipScrollTarget = null;

        let gridPt = 8, snapTolPx = 5, MIN_GRID_CELLS = 3;

        let fields = [], selectedIds = [], dragging = null, editingId = null;
        let isNativeDragging = false;
        let currentDragDataType = null;
        let currentTplDrag = null;

        function ensureGhost() {
            if (!overlay) return;
            if (!ghostWrap || !overlay.contains(ghostWrap)) {
                if (ghostWrap) ghostWrap.remove();
                ghostWrap = document.createElement('div');
                ghostWrap.id = 'ghost';
                overlay.appendChild(ghostWrap);
            }
            ghostWrap.innerHTML = '';
        }
        function clearGhost() { if (ghostWrap) { ghostWrap.remove(); ghostWrap = null; } }
        function drawGhostTemplate(tpl, x, y) {
            if (!tpl || !viewport) return;
            ensureGhost();
            for (const it of tpl.items) {
                const s = snapRectPx(x + ptToPx(it.dx), y + ptToPx(it.dy), ptToPx(it.w), ptToPx(it.h));
                const b = document.createElement('div');
                b.className = 'ghost-box';
                Object.assign(b.style, { left: s.left + 'px', top: s.top + 'px', width: s.width + 'px', height: s.height + 'px' });
                const lbl = document.createElement('span');
                lbl.textContent = it.name ?? 'Signature';
                b.appendChild(lbl);
                ghostWrap.appendChild(b);
            }
        }
        function ptToPx(v) { return v * scale; }
        function pxToPt(v) { return v / scale; }
        function pageHeightPt() { return viewport.height / scale; }
        function gridPx() { return Math.max(4, Math.round(ptToPx(gridPt))); }
        function applyGridBg() { if (overlay) overlay.style.setProperty('--grid', gridPx() + 'px'); }
        function snapValPx(v, candidates) {
            let best = v;
            for (const c of candidates) { if (Math.abs(v - c) <= snapTolPx) { best = c; break; } }
            return best;
        }
        function guideCandidatesPx(includeBoxes = true) {
            const xCands = [], yCands = [];
            if (!overlay) return { xCands, yCands };
            const w = overlay.offsetWidth, h = overlay.offsetHeight;
            xCands.push(0, w / 2, w);
            yCands.push(0, h / 2, h);
            if (includeBoxes) {
                overlay.querySelectorAll('.box').forEach(b => {
                    const id = b.dataset.id;
                    if (selectedIds.includes(id)) return;
                    const x = b.offsetLeft, y = b.offsetTop, bw = b.offsetWidth, bh = b.offsetHeight;
                    xCands.push(x, x + bw / 2, x + bw);
                    yCands.push(y, y + bh / 2, y + bh);
                });
            }
            return { xCands, yCands };
        }
        function snapRectPx(left, top, width, height) {
            const { xCands, yCands } = guideCandidatesPx(true);
            const sx1 = snapValPx(left, xCands), sx2 = snapValPx(left + width, xCands);
            const sy1 = snapValPx(top, yCands), sy2 = snapValPx(top + height, yCands);
            let l = Math.abs(sx1 - left) <= Math.abs(sx2 - (left + width)) ? sx1 : (sx2 - width);
            let t = Math.abs(sy1 - top) <= Math.abs(sy2 - (top + height)) ? sy1 : (sy2 - height);
            return { left: l, top: t, width, height };
        }

        function post(msg) { chrome.webview.postMessage(JSON.stringify(msg)); }

        async function renderPageToCache(num) {
            if (pageCache[num]) return pageCache[num];
            const page = await pdfDoc.getPage(num);
            const pageViewport = page.getViewport({ scale });
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = pageViewport.width;
            offscreenCanvas.height = pageViewport.height;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            await page.render({ canvasContext: offscreenCtx, viewport: pageViewport }).promise;
            const cacheEntry = { canvas: offscreenCanvas, viewport: pageViewport };
            pageCache[num] = cacheEntry;
            return cacheEntry;
        }

        function preloadAdjacentPages(num) {
            setTimeout(() => {
                const pagesToLoad = [num - 1, num + 1];
                for (const pageNumToLoad of pagesToLoad) {
                    if (pageNumToLoad > 0 && pageNumToLoad <= pdfDoc.numPages && !pageCache[pageNumToLoad]) {
                        renderPageToCache(pageNumToLoad).catch(err => console.error(`Failed to pre-render page ${pageNumToLoad}`, err));
                    }
                }
            }, 100);
        }

        async function displayPage(num) {
            const cacheEntry = pageCache[num] || await renderPageToCache(num);
            viewport = cacheEntry.viewport;

            const oldPage = pageWrap.querySelector('.page-container.visible');
            const newPage = document.createElement('div');
            newPage.className = 'page-container hidden';

            const pageCanvas = cacheEntry.canvas;
            pageCanvas.id = 'pdfCanvas';
            newPage.appendChild(pageCanvas);

            if (!overlay) {
                overlay = createOverlay();
            }
            newPage.appendChild(overlay);

            pageWrap.appendChild(newPage);

            pageWrap.style.width = viewport.width + 'px';
            pageWrap.style.height = viewport.height + 'px';

            post({ type: 'meta', numPages: pdfDoc.numPages, page: num });
            markCurrentThumb(num);
            applyGridBg();
            redraw();
            updateSelectionActions();

            setTimeout(() => {
                if (oldPage) {
                    oldPage.classList.remove('visible');
                    oldPage.classList.add('hidden');
                }
                newPage.classList.add('visible');
                newPage.classList.remove('hidden');

                if (oldPage) {
                    setTimeout(() => oldPage.remove(), 250);
                }
            }, 10);

            if (flipScrollTarget === 'top') container.scrollTop = 1;
            else if (flipScrollTarget === 'bottom') container.scrollTop = Math.max(0, container.scrollHeight - container.clientHeight - 1);
            flipScrollTarget = null;

            preloadAdjacentPages(num);
        }

        window.setPage = async function (num) {
            if (isFlipping || num === pageNum) return;
            isFlipping = true;
            pageNum = Math.min(Math.max(1, num), pdfDoc.numPages);
            selectedIds = [];
            updateSelectionActions();
            await displayPage(pageNum);
            isFlipping = false;
        };

        function createOverlay() {
            const ov = document.createElement('div');
            ov.id = 'overlay';
            ov.tabIndex = 0;
            // ov.className = 'gridbg'; // disabled default grid

            ov.addEventListener('mousedown', handleMouseDown);
            ov.addEventListener('mousemove', handleMouseMove);
            ov.addEventListener('keydown', handleKeyDown);
            ov.addEventListener('dblclick', handleDoubleClick);

            ['dragenter', 'dragover'].forEach(type => ov.addEventListener(type, handleOverlayDragOver));
            ov.addEventListener('drop', handleOverlayDrop);
            ov.addEventListener('dragleave', handleOverlayDragLeave);
            ov.addEventListener('wheel', handleWheel, { passive: false });

            // Gửi tọa độ chuột về C#
            let lastMove = 0;
            ov.addEventListener('mousemove', e => {
                if (Date.now() - lastMove < 50) return;
                lastMove = Date.now();
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const Hpt = pageHeightPt();
                const xpt = pxToPt(x);
                const ypt = Hpt - pxToPt(y);
                post({ type: 'mouseMove', pt: { x: xpt, y: ypt } });
            });
            ov.addEventListener('mouseleave', e => {
                post({ type: 'mouseMove', pt: { x: 0, y: 0 } });
            });

            return ov;
        }

        async function buildThumbs() {
            thumbList.innerHTML = '';
            thumbCanvases = [];
            const desiredWidth = 140;

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const vp0 = page.getViewport({ scale: 1 });
                const scaleT = desiredWidth / vp0.width;
                const vp = page.getViewport({ scale: scaleT });

                const cv = document.createElement('canvas');
                cv.width = vp.width; cv.height = vp.height;
                const cctx = cv.getContext('2d');
                cctx.fillStyle = 'white'; cctx.fillRect(0, 0, cv.width, cv.height);
                await page.render({ canvasContext: cctx, viewport: vp }).promise;

                const item = document.createElement('div');
                item.className = 'thumb'; item.dataset.page = i;
                item.appendChild(cv);

                const pspan = document.createElement('div');
                pspan.className = 'pnum'; pspan.textContent = `Page ${i}`;
                item.appendChild(pspan);

                item.addEventListener('click', () => { flipScrollTarget = 'top'; window.setPage(i); });
                thumbList.appendChild(item);
                thumbCanvases.push(cv);
            }
            markCurrentThumb(pageNum);
        }
        function markCurrentThumb(n) {
            document.querySelectorAll('.thumb').forEach(el => el.classList.remove('cur'));
            const el = document.querySelector(`.thumb[data-page="${n}"]`);
            if (el) {
                el.classList.add('cur');
                if (el.scrollIntoView) el.scrollIntoView({ block: 'nearest' });
            }
        }

        function beginEditName(id) {
            if (selectedIds.length !== 1 || selectedIds[0] !== id) return;

            const f = fields.find(t => t.id === id); if (!f) return;
            if (editingId && document.getElementById('nameEditor')) {
                document.getElementById('nameEditor').remove();
                editingId = null;
            }
            const box = overlay.querySelector(`.box[data-id="${id}"]`); if (!box) return;

            const cx = box.offsetLeft + box.offsetWidth / 2, cy = box.offsetTop + box.offsetHeight / 2;
            const w = Math.max(60, Math.min(260, box.offsetWidth - 12));
            const input = document.createElement('input');
            input.id = 'nameEditor'; input.type = 'text'; input.value = f.name;
            Object.assign(input.style, {
                position: 'absolute', left: cx + 'px', top: cy + 'px', transform: 'translate(-50%,-50%)',
                width: w + 'px', padding: '4px 8px', fontFamily: 'system-ui,Segoe UI,Roboto,Arial',
                fontSize: '12px', background: '#fff', border: '1px solid #1976d2', borderRadius: '8px',
                boxShadow: '0 2px 8px rgba(0,0,0,.12)', zIndex: 2147483647
            });
            overlay.appendChild(input);
            editingId = id; input.focus(); input.select();

            function commit() {
                if (!document.getElementById('nameEditor')) return;
                const newName = input.value.trim();
                input.remove(); editingId = null;
                if (newName && newName !== f.name) {
                    post({ type: 'renameField', id: f.id, name: newName, page: pageNum });
                } else { redraw(); }
            }
            function cancel() { if (document.getElementById('nameEditor')) { input.remove(); editingId = null; redraw(); } }
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') { e.preventDefault(); commit(); }
                if (e.key === 'Escape') { e.preventDefault(); cancel(); }
                e.stopPropagation();
            });
            input.addEventListener('blur', () => commit());
        }

        function redraw() {
            if (!overlay || !viewport) return;
            overlay.innerHTML = '';
            ghostWrap = null;

            const Hpt = pageHeightPt();
            overlay.style.width = viewport.width + 'px';
            overlay.style.height = viewport.height + 'px';

            fields.forEach(f => {
                const div = document.createElement('div');
                div.className = 'box ' + (f.required ? 'req' : 'nreq') + (selectedIds.includes(f.id) ? ' sel' : '');
                const xpx = ptToPx(f.x), wpx = ptToPx(f.w), hpx = ptToPx(f.h);
                const ypx = ptToPx(Hpt - f.y - f.h);
                Object.assign(div.style, { left: xpx + 'px', top: ypx + 'px', width: wpx + 'px', height: hpx + 'px' });
                div.title = f.name; div.dataset.id = f.id;

                div.draggable = true;

                const lbl = document.createElement('span');
                lbl.textContent = f.name;
                Object.assign(lbl.style, {
                    position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%,-50%)', padding: '2px 6px',
                    fontFamily: 'system-ui,Segoe UI,Roboto,Arial', fontSize: '12px', background: 'rgba(255,255,255,.7)',
                    borderRadius: '6px', pointerEvents: 'none', maxWidth: '100%', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis'
                });
                div.appendChild(lbl);

                if (selectedIds.length > 0 && f.id === selectedIds[selectedIds.length - 1]) {
                    const h = document.createElement('div');
                    ['tl', 'tr', 'bl', 'br'].forEach(pos => { const h = document.createElement('div'); h.className = 'handle ' + pos; h.dataset.id = f.id; h.dataset.pos = pos; div.appendChild(h); });
                }
                overlay.appendChild(div);
            });
            overlay.focus();
        }

        function handleMouseDown(e) {
            if (isNativeDragging || editingId) return;
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const t = e.target;

            if (t.classList.contains('handle')) {
                const id = t.dataset.id; const corner = t.dataset.pos || 'br';
                const f = fields.find(i => i.id === id); if (!f) return;
                dragging = { mode: 'resize', id: id, corner, sx: x, sy: y, startRect: { ...f } };
                overlay.focus(); e.preventDefault(); return;
            }

            const box = t.closest('.box');
            if (box) {
                const id = box.dataset.id;
                if (e.shiftKey) {
                    if (selectedIds.includes(id)) {
                        selectedIds = selectedIds.filter(sid => sid !== id);
                    } else {
                        selectedIds.push(id);
                    }
                } else {
                    if (!selectedIds.includes(id)) {
                        selectedIds = [id];
                    }
                }

                dragging = {
                    mode: 'move',
                    sx: x, sy: y,
                    startRects: fields.filter(f => selectedIds.includes(f.id)).map(f => ({ ...f }))
                };
                redraw();
                updateSelectionActions();
                overlay.focus();
                return;
            }

            selectedIds = [];
            redraw();
            updateSelectionActions();
            dragging = { mode: 'draw', sx: x, sy: y, startRect: null, moved: false };
            const draft = document.createElement('div');
            draft.className = 'box req';
            Object.assign(draft.style, { left: x + 'px', top: y + 'px', width: '0px', height: '0px' });
            draft.id = 'draft';
            overlay.appendChild(draft); overlay.focus();
        }

        function handleMouseMove(e) {
            if (isNativeDragging || !dragging) return;
            const rect = overlay.getBoundingClientRect();
            let x = e.clientX - rect.left, y = e.clientY - rect.top;

            if (dragging.mode === 'draw') {
                const draft = document.getElementById('draft');
                if (!draft) return;
                let left = Math.min(dragging.sx, x), top = Math.min(dragging.sy, y);
                let w = Math.abs(x - dragging.sx), h = Math.abs(y - dragging.sy);
                dragging.moved ||= (w > 2 || h > 2);
                const s = snapRectPx(left, top, w, h);
                Object.assign(draft.style, { left: s.left + 'px', top: s.top + 'px', width: s.width + 'px', height: s.height + 'px' });
                return;
            }

            if (dragging.mode === 'move') {
                const dx = x - dragging.sx, dy = y - dragging.sy;
                dragging.startRects.forEach(startRect => {
                    const f = fields.find(field => field.id === startRect.id);
                    if (f) {
                        const newXPt = startRect.x + pxToPt(dx);
                        const newYPt = startRect.y - pxToPt(dy);
                        f.x = newXPt;
                        f.y = newYPt;
                    }
                });
                redraw();
                return;
            }

            if (dragging.mode === 'resize') {
                const f0 = dragging.startRect;
                const Hpt0 = pageHeightPt();
                const l0 = ptToPx(f0.x);
                const t0 = ptToPx(Hpt0 - f0.y - f0.h);
                const w0 = ptToPx(f0.w);
                const h0 = ptToPx(f0.h);
                let l = l0, t = t0, w = Math.max(1, w0), h = Math.max(1, h0);
                const corner = dragging.corner || 'br';
                if (corner === 'br') { w = Math.max(1, x - l0); h = Math.max(1, y - t0); }
                else if (corner === 'tr') { w = Math.max(1, x - l0); t = Math.min(y, t0 + h0 - 1); h = Math.max(1, (t0 + h0) - t); }
                else if (corner === 'bl') { l = Math.min(x, l0 + w0 - 1); w = Math.max(1, (l0 + w0) - l); h = Math.max(1, y - t0); }
                else { l = Math.min(x, l0 + w0 - 1); t = Math.min(y, t0 + h0 - 1); w = Math.max(1, (l0 + w0) - l); h = Math.max(1, (t0 + h0) - t); }
                const s = snapRectPx(l, t, w, h);
                const wpt = pxToPt(s.width), hpt = pxToPt(s.height);
                const xpt = pxToPt(s.left), ypt = Hpt0 - pxToPt(s.top) - hpt;
                const f = fields.find(t => t.id === dragging.id);
                if (f) { f.x = xpt; f.y = ypt; f.w = wpt; f.h = hpt; redraw(); }
                return;
            }
        }

        window.addEventListener('mouseup', e => {
            if (!dragging) return;
            if (dragging.mode === 'draw') {
                const draft = document.getElementById('draft');
                if (draft) {
                    const xpx = parseFloat(draft.style.left), ypx = parseFloat(draft.style.top);
                    const wpx = parseFloat(draft.style.width), hpx = parseFloat(draft.style.height);
                    const minPx = MIN_GRID_CELLS * gridPx();
                    if (!dragging.moved || wpx < minPx || hpx < minPx) { draft.remove(); dragging = null; return; }
                    draft.remove();
                    const Hpt = pageHeightPt();
                    const xpt = pxToPt(xpx), wpt = pxToPt(wpx), hpt = pxToPt(hpx);
                    const ypt = Hpt - pxToPt(ypx) - hpt;
                    post({ type: 'addField', page: pageNum, rect: { x: xpt, y: ypt, w: wpt, h: hpt, required: true } });
                }
                dragging = null; return;
            }

            const itemsToUpdate = dragging.mode === 'move' ? dragging.startRects : [dragging.startRect];
            itemsToUpdate.forEach(item => {
                const f = fields.find(t => t.id === item.id);
                if (f) post({ type: 'updateField', id: f.id, page: pageNum, rect: { x: f.x, y: f.y, w: f.w, h: f.h } });
            });
            dragging = null;
        });

        function handleKeyDown(e) {
            if (editingId) return;
            if (e.key === 'PageDown' && pdfDoc.numPages) {
                flipScrollTarget = 'top'; window.setPage(pageNum + 1); e.preventDefault(); return;
            }
            if (e.key === 'PageUp' && pageNum > 1) {
                flipScrollTarget = 'bottom'; window.setPage(pageNum - 1); e.preventDefault(); return;
            }

            if (selectedIds.length === 0) return;

            const stepPt = e.shiftKey ? 5 : 1;
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                e.preventDefault();
                fields.forEach(f => {
                    if (selectedIds.includes(f.id)) {
                        if (e.key === 'ArrowLeft') f.x -= stepPt; if (e.key === 'ArrowRight') f.x += stepPt;
                        if (e.key === 'ArrowUp') f.y += stepPt; if (e.key === 'ArrowDown') f.y -= stepPt;
                        post({ type: 'updateField', id: f.id, page: pageNum, rect: { x: f.x, y: f.y, w: f.w, h: f.h } });
                    }
                });
                redraw();
            }

            if (e.key.toLowerCase() === 'r') {
                e.preventDefault();
                selectedIds.forEach(id => post({ type: 'toggleRequired', id: id, page: pageNum }));
            }
            if (e.key === 'Delete') {
                e.preventDefault();
                selectedIds.forEach(id => post({ type: 'deleteField', id: id, page: pageNum }));
            }
            if ((e.key === 'Enter' || e.key === 'F2') && selectedIds.length === 1) {
                beginEditName(selectedIds[0]); e.preventDefault();
            }
        }
        function handleDoubleClick(e) {
            const box = e.target.closest && e.target.closest('.box'); if (!box) return;
            const id = box.dataset.id; if (!id) return;
            e.preventDefault(); e.stopPropagation();
            if (selectedIds.length === 1 && selectedIds[0] === id) {
                beginEditName(id);
            }
        }

        function handleDragStart(e) {
            isNativeDragging = true;
            const tplEl = e.target.closest('.tpl');
            const boxEl = e.target.closest('.box');

            if (tplEl) {
                currentDragDataType = 'template';
                const tplName = tplEl.querySelector('.tpl-name').textContent;
                const template = templatesUi.find(t => t.name === tplName);
                if (template) {
                    currentTplDrag = template;
                    e.dataTransfer.setData('application/json', JSON.stringify(template));
                    const img = new Image(); img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
                    e.dataTransfer.setDragImage(img, 0, 0);
                }
            } else if (boxEl && selectedIds.includes(boxEl.dataset.id)) {
                currentDragDataType = 'selection';
                const selectedFields = fields.filter(f => selectedIds.includes(f.id));
                e.dataTransfer.setData('application/json', JSON.stringify(selectedFields));

                const ghost = document.createElement('div');
                ghost.style.cssText = 'position: absolute; left: -1000px; padding: 5px 10px; background: rgba(25, 118, 210, 0.8); color: white; border-radius: 8px;';
                ghost.textContent = `Create Template (${selectedIds.length} items)`;
                document.body.appendChild(ghost);
                e.dataTransfer.setDragImage(ghost, 0, 0);
                setTimeout(() => document.body.removeChild(ghost), 0);
            } else {
                e.preventDefault();
            }
        }

        function handleOverlayDragOver(e) {
            if (currentDragDataType === 'template' && currentTplDrag) {
                e.preventDefault(); e.dataTransfer.dropEffect = 'copy';
                const tpl = currentTplDrag;
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                drawGhostTemplate(tpl, x, y);
            }
        }
        function handleOverlayDrop(e) {
            if (currentDragDataType === 'template') {
                e.preventDefault();
                const tpl = JSON.parse(e.dataTransfer.getData('application/json'));
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const Hpt = pageHeightPt();
                for (const it of tpl.items) {
                    const s = snapRectPx(x + ptToPx(it.dx), y + ptToPx(it.dy), ptToPx(it.w), ptToPx(it.h));
                    const xpt = pxToPt(s.left), ypt = Hpt - pxToPt(s.top) - it.h;
                    post({ type: 'addField', page: pageNum, name: it.name, rect: { x: xpt, y: ypt, w: it.w, h: it.h, required: !!it.required } });
                }
            }
        }
        function handleOverlayDragLeave(e) {
            if (!e.currentTarget.contains(e.relatedTarget)) clearGhost();
        }

        document.addEventListener('dragend', () => {
            isNativeDragging = false;
            currentDragDataType = null;
            currentTplDrag = null;
            clearGhost();
        });

        function renderTplBar() {
            const list = document.getElementById('tpllist'); list.innerHTML = '';
            const pencilSvg = `<svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M12 20h9" /><path d="M16.5 3.5l4 4L7 21H3v-4L16.5 3.5z" /></svg>`;
            const trashSvg = `<svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M3 6h18" /><path d="M8 6V4h8v2" /><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" /><path d="M10 11v6M14 11v6" /></svg>`;
            const esc = s => (s ?? '').replace(/[&<>"]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[m]));

            templatesUi.forEach(t => {
                const d = document.createElement('div'); d.className = 'tpl'; d.draggable = true;
                d.innerHTML = `<div class="tpl-name">${esc(t.name)}</div><button class="icon-btn icon-edit" title="Edit" aria-label="Edit" type="button">${pencilSvg}</button><button class="icon-btn icon-del"  title="Delete" aria-label="Delete" type="button">${trashSvg}</button>`;

                const btnEdit = d.querySelector('.icon-edit');
                btnEdit.addEventListener('mousedown', e => e.stopPropagation());
                btnEdit.addEventListener('click', ev => { ev.stopPropagation(); ev.preventDefault(); openTplEditor(structuredClone(t)); });
                const btnDel = d.querySelector('.icon-del');
                btnDel.addEventListener('mousedown', e => e.stopPropagation());
                btnDel.addEventListener('click', ev => { ev.stopPropagation(); ev.preventDefault(); if (confirm(`Delete template "${t.name}"?`)) post({ type: 'deleteTemplate', name: t.name }); });
                list.appendChild(d);
            });
        }

        const btnNewTpl = document.getElementById('btnNewTpl');
        const tplModal = document.getElementById('tplModal');
        const tplTitle = document.getElementById('tplTitle');
        const tplName = document.getElementById('tplName');
        const tplItemsBody = document.getElementById('tplItemsBody');
        const btnAddItem = document.getElementById('btnAddItem');
        const btnTplSave = document.getElementById('btnTplSave');
        const btnTplCancel = document.getElementById('btnTplCancel');
        const btnTplDelete = document.getElementById('btnTplDelete');
        let editingTemplate = null;
        function openTplEditor(tpl) {
            editingTemplate = tpl || { name: '', items: [] };
            tplTitle.textContent = editingTemplate.name ? `Edit: ${editingTemplate.name}` : 'New Template';
            tplName.value = editingTemplate.name || ''; tplItemsBody.innerHTML = '';
            (editingTemplate.items || []).forEach(addTplItemRow);
            tplModal.style.display = 'flex';
            btnTplDelete.style.display = editingTemplate && templatesUi.some(x => x.name === editingTemplate.name) ? 'inline-block' : 'none';
        }
        function closeTplEditor() { tplModal.style.display = 'none'; editingTemplate = null; }
        function addTplItemRow(item) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td><input type="text" value="${item?.name ?? 'Signature'}" /></td><td><input type="number" step="0.5" value="${item?.w ?? 120}"/></td><td><input type="number" step="0.5" value="${item?.h ?? 60}"/></td><td style="text-align:center"><input type="checkbox" ${item?.required !== false ? 'checked' : ''}/></td><td><input type="number" step="0.5" value="${item?.dx ?? 0}"/></td><td><input type="number" step="0.5" value="${item?.dy ?? 0}"/></td><td><button class="btn-sm">✕</button></td>`;
            tr.querySelector('button').addEventListener('click', () => tr.remove()); tplItemsBody.appendChild(tr);
        }
        function collectTplItems() {
            const rows = Array.from(tplItemsBody.querySelectorAll('tr'));
            return rows.map(r => {
                const [nameI, wI, hI, reqI, dxI, dyI] = r.querySelectorAll('input');
                return { name: nameI.value.trim() || 'Signature', w: parseFloat(wI.value) || 1, h: parseFloat(hI.value) || 1, required: !!reqI.checked, dx: parseFloat(dxI.value) || 0, dy: parseFloat(dyI.value) || 0 };
            });
        }
        btnNewTpl.addEventListener('click', () => openTplEditor({ name: '', items: [] }));
        btnAddItem.addEventListener('click', (e) => { e.preventDefault(); addTplItemRow({}); });
        btnTplCancel.addEventListener('click', (e) => { e.preventDefault(); closeTplEditor(); });
        btnTplSave.addEventListener('click', (e) => {
            e.preventDefault(); const name = tplName.value.trim(); if (!name) { alert('Template name is required'); return; }
            const items = collectTplItems(); if (!items.length) { alert('Add at least one item'); return; }
            post({ type: 'saveTemplate', template: { name, items } }); closeTplEditor();
        });
        btnTplDelete.addEventListener('click', (e) => {
            e.preventDefault(); const name = tplName.value.trim(); if (!name) return;
            if (confirm(`Delete template "${name}"?`)) { post({ type: 'deleteTemplate', name }); closeTplEditor(); }
        });
        tplModal.addEventListener('click', (e) => { if (e.target === tplModal) closeTplEditor(); });

        function handleWheel(e) {
            if (!pdfDoc || editingId || dragging || isFlipping) return;
            const canScroll = (container.scrollHeight - container.clientHeight) > 2;
            const nearTop = !canScroll || container.scrollTop <= 0;
            const nearBottom = !canScroll || (container.scrollTop + container.clientHeight >= container.scrollHeight - 2);
            if (e.deltaY > 0 && nearBottom && pageNum < pdfDoc.numPages) {
                e.preventDefault(); flipScrollTarget = 'top'; window.setPage(pageNum + 1);
            } else if (e.deltaY < 0 && nearTop && pageNum > 1) {
                e.preventDefault(); flipScrollTarget = 'bottom'; window.setPage(pageNum - 1);
            }
        }
        container.addEventListener('wheel', handleWheel, { passive: false });
        // Undo / Redo shortcuts
        window.addEventListener('keydown', (e) => {
            const ctrl = e.ctrlKey || e.metaKey;
            if (ctrl && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); post({ type: 'undo' }); }
            else if ((ctrl && (e.key === 'y' || e.key === 'Y')) || (ctrl && e.shiftKey && (e.key === 'z' || e.key === 'Z'))) { e.preventDefault(); post({ type: 'redo' }); }
        });


        window.setFields = function (list) {
            fields = list || [];
            selectedIds = selectedIds.filter(id => fields.some(f => f.id === id));
            redraw();
            updateSelectionActions();
            if (overlay) overlay.focus();
        };

        window.zoomIn = async function () {
            scale = Math.min(scale + 0.25, 4); pageCache = {};
            pageWrap.querySelectorAll('.page-container').forEach(el => el.remove());
            await displayPage(pageNum);
        };
        window.zoomOut = async function () {
            scale = Math.max(scale - 0.25, 0.5); pageCache = {};
            pageWrap.querySelectorAll('.page-container').forEach(el => el.remove());
            await displayPage(pageNum);
        };
        window.setTemplates = function (list) { templatesUi = list || []; renderTplBar(); };

        window.setAddedFields = function (fields) {
            const listDiv = document.getElementById('addedfieldslist');
            listDiv.innerHTML = '';

            if (!fields || fields.length === 0) {
                listDiv.innerHTML = '<div class="empty-state">No fields added.</div>';
                return;
            }

            const sortedFields = fields.sort((a, b) => {
                if (a.page < b.page) return -1;
                if (a.page > b.page) return 1;
                return a.name.localeCompare(b.name);
            });

            sortedFields.forEach(field => {
                const item = document.createElement('div');
                item.className = 'field-item';
                item.textContent = `${field.name} (Page ${field.page})`;
                item.title = `Double-click to go to ${field.name} on Page ${field.page}`;

                item.dataset.fieldId = field.id;
                item.dataset.page = field.page;

                item.addEventListener('dblclick', async () => {
                    const targetPage = parseInt(item.dataset.page, 10);
                    const fieldId = item.dataset.fieldId;

                    if (isNaN(targetPage) || !fieldId) return;
                    if (pageNum !== targetPage) {
                        await window.setPage(targetPage);
                    }

                    selectedIds = [fieldId];
                    redraw();
                    updateSelectionActions();

                    const box = overlay.querySelector(`.box[data-id="${fieldId}"]`);
                    if (box && box.scrollIntoView) {
                        box.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });

                listDiv.appendChild(item);
            });
        };

        function setupLeftPanelDropZone() {
            const leftPanel = document.getElementById('left-panel');

            leftPanel.addEventListener('dragover', e => {
                if (currentDragDataType === 'selection') {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    leftPanel.classList.add('dragover');
                }
            });

            leftPanel.addEventListener('dragleave', e => {
                leftPanel.classList.remove('dragover');
            });

            leftPanel.addEventListener('drop', e => {
                e.preventDefault();
                leftPanel.classList.remove('dragover');

                if (currentDragDataType === 'selection') {
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    createTemplateFromFields(data);
                }
            });
        }

        function createTemplateFromFields(selectedFields) {
            const anchor = selectedFields.reduce((acc, field) => {
                const yUi = pageHeightPt() - field.y - field.h;
                const accYUi = pageHeightPt() - acc.y - acc.h;
                if (yUi < accYUi) return field;
                if (yUi === accYUi && field.x < acc.x) return field;
                return acc;
            });

            const templateItems = selectedFields.map(field => ({
                name: field.name, w: field.w, h: field.h, required: field.required,
                dx: field.x - anchor.x, dy: field.y - anchor.y
            }));

            openTplEditor({ name: '', items: templateItems });
        }

        function updateSelectionActions() {
            const leftPanelActions = document.getElementById('selection-actions');
            leftPanelActions.style.display = selectedIds.length > 0 ? 'block' : 'none';
        }

        document.getElementById('btnCreateFromSelection').addEventListener('click', () => {
            if (selectedIds.length === 0) return;
            const selectedFields = fields.filter(f => selectedIds.includes(f.id));
            createTemplateFromFields(selectedFields);
        });

        function getSelectedFields() {
            if (selectedIds.length === 0) return [];
            return selectedIds.map(id => fields.find(f => f.id === id)).filter(Boolean);
        }

        function commitFieldChanges(updatedFields) {
            updatedFields.forEach(f => {
                post({ type: 'updateField', id: f.id, page: pageNum, rect: { x: f.x, y: f.y, w: f.w, h: f.h } });
            });
            redraw();
        }

        function setupAlignmentActions() {
            const getAnchor = () => {
                if (selectedIds.length === 0) return null;
                return fields.find(f => f.id === selectedIds[selectedIds.length - 1]);
            };

            document.getElementById('btn-match-w').addEventListener('click', () => {
                const anchor = getAnchor(); if (!anchor) return;
                const selected = getSelectedFields();
                selected.forEach(f => f.w = anchor.w);
                commitFieldChanges(selected);
            });

            document.getElementById('btn-match-h').addEventListener('click', () => {
                const anchor = getAnchor(); if (!anchor) return;
                const selected = getSelectedFields();
                selected.forEach(f => f.h = anchor.h);
                commitFieldChanges(selected);
            });

            document.getElementById('btn-match-wh').addEventListener('click', () => {
                const anchor = getAnchor(); if (!anchor) return;
                const selected = getSelectedFields();
                selected.forEach(f => { f.w = anchor.w; f.h = anchor.h; });
                commitFieldChanges(selected);
            });

            const alignFields = (edge) => {
                const anchor = getAnchor(); if (!anchor) return;
                const selected = getSelectedFields();
                selected.forEach(f => {
                    if (f.id === anchor.id) return;
                    switch (edge) {
                        case 'left': f.x = anchor.x; break;
                        case 'right': f.x = anchor.x + anchor.w - f.w; break;
                        case 'top': f.y = anchor.y; break;
                        case 'bottom': f.y = anchor.y + anchor.h - f.h; break;
                        case 'h-center': f.x = anchor.x + (anchor.w / 2) - (f.w / 2); break;
                        case 'v-center': f.y = anchor.y + (anchor.h / 2) - (f.h / 2); break;
                    }
                });
                commitFieldChanges(selected);
            };

            document.getElementById('btn-align-left').addEventListener('click', () => alignFields('left'));
            document.getElementById('btn-align-right').addEventListener('click', () => alignFields('right'));
            document.getElementById('btn-align-top').addEventListener('click', () => alignFields('top'));
            document.getElementById('btn-align-bottom').addEventListener('click', () => alignFields('bottom'));
            document.getElementById('btn-align-h-center').addEventListener('click', () => alignFields('h-center'));
            document.getElementById('btn-align-v-center').addEventListener('click', () => alignFields('v-center'));

            const distributeFields = (axis) => {
                const selected = getSelectedFields();
                if (selected.length < 3) return;

                if (axis === 'v') {
                    selected.sort((a, b) => b.y - a.y);
                    const topField = selected[0];
                    const bottomField = selected[selected.length - 1];
                    const totalHeight = selected.reduce((sum, f) => sum + f.h, 0);
                    const totalSpace = topField.y + topField.h - bottomField.y;
                    const gap = (totalSpace - totalHeight) / (selected.length - 1);

                    let currentY = topField.y;
                    selected.forEach(f => { f.y = currentY; currentY -= (f.h + gap); });
                } else {
                    selected.sort((a, b) => a.x - b.x);
                    const leftField = selected[0];
                    const rightField = selected[selected.length - 1];
                    const totalWidth = selected.reduce((sum, f) => sum + f.w, 0);
                    const totalSpace = rightField.x + rightField.w - leftField.x;
                    const gap = (totalSpace - totalWidth) / (selected.length - 1);

                    let currentX = leftField.x;
                    selected.forEach(f => { f.x = currentX; currentX += f.w + gap; });
                }
                commitFieldChanges(selected);
            };

            document.getElementById('btn-dist-h').addEventListener('click', () => distributeFields('h'));
            document.getElementById('btn-dist-v').addEventListener('click', () => distributeFields('v'));
        }

        // *** FIX: This is the new entry point, called by C#. ***
        async function initializePdfViewer(pdfUrl) {
            document.body.addEventListener('dragstart', handleDragStart);

            pdfDoc = await pdfjsLib.getDocument(pdfUrl).promise;
            renderTplBar();
            await buildThumbs();
            await displayPage(pageNum);
            setupLeftPanelDropZone();

            setupAlignmentActions();
        }
    </script>
    <script>
        // === Minimal Grid/Snap/Ruler toggles for C# toolbar ===
        (function () {
            const GRID_SIZE = 10;
            let showGrid = false;
            let snapEnabled = true;
            let showRuler = false;

            const gridCanvas = document.getElementById('grid-overlay');
            const rulerTop = document.getElementById('ruler-top');
            const rulerLeft = document.getElementById('ruler-left');

            function getPdfRect() {
                const wrap = document.getElementById('pagewrap');
                if (!wrap) return null;
                const rect = wrap.getBoundingClientRect();
                return { pdf: wrap, rect };
            }

            function resizeOverlays() {
                const g = getPdfRect();
                if (!g) return;
                const { pdf, rect } = g;
                const dpr = window.devicePixelRatio || 1;

                gridCanvas.style.width = rect.width + 'px';
                gridCanvas.style.height = rect.height + 'px';
                gridCanvas.width = Math.round(rect.width * dpr);
                gridCanvas.height = Math.round(rect.height * dpr);
                const ctx = gridCanvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                gridCanvas.style.left = '0px';
                gridCanvas.style.top = '0px';
                rulerTop.style.left = '0px';
                rulerTop.style.top = '-24px';
                rulerTop.style.width = rect.width + 'px';
                rulerLeft.style.left = '-24px';
                rulerLeft.style.top = '0px';
                rulerLeft.style.height = rect.height + 'px';
                drawGrid();
            }

            function drawGrid() {
                const ctx = gridCanvas.getContext('2d');
                ctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                if (!showGrid) return;

                ctx.save();
                ctx.globalAlpha = 0.02;    // nhạt hơn nữa
                ctx.lineWidth = 0.5;       // nét mảnh hơn (mặc định 1)

                for (let x = 0; x < gridCanvas.width; x += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, 0);
                    ctx.lineTo(x + 0.5, gridCanvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < gridCanvas.height; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + 0.5);
                    ctx.lineTo(gridCanvas.width, y + 0.5);
                    ctx.stroke();
                }

                ctx.restore(); // trả lại alpha & lineWidth ban đầu
            }


            function drawRulers() {
                rulerTop.style.display = showRuler ? 'block' : 'none';
                rulerLeft.style.display = showRuler ? 'block' : 'none';
            }

            // Expose minimal API for C#
            window.toggleGrid = function () { showGrid = !showGrid; drawGrid(); };
            window.toggleSnap = function () { snapEnabled = !snapEnabled; document.body.dataset.snap = snapEnabled ? '1' : '0'; };
            window.toggleRuler = function () { showRuler = !showRuler; drawRulers(); };

            // Optional helper if your drag code wants to use snapping
            window.snapEnabled = () => snapEnabled;
            window.snapVal = (v) => snapEnabled ? Math.round(v / GRID_SIZE) * GRID_SIZE : v;

            window.addEventListener('load', resizeOverlays);
            window.addEventListener('resize', resizeOverlays);
        })();
    </script>

    <script>
        // ===== FINAL PATCH: Robust Grid toggle + Floating align toolbar =====
        (function () {
            // --- GRID ---
            const wrap = document.getElementById('pagewrap');
            let canvas = document.getElementById('grid-overlay');
            if (!canvas && wrap) {
                canvas = document.createElement('canvas');
                canvas.id = 'grid-overlay';
                wrap.appendChild(canvas);
            }
            const GRID_SIZE = 20; // larger cells
            let gridOn = false;

            function sizeGrid() {
                if (!wrap || !canvas) return;
                const rect = wrap.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.style.left = '0px';
                canvas.style.top = '0px';
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                canvas.width = Math.max(1, Math.round(rect.width * dpr));
                canvas.height = Math.max(1, Math.round(rect.height * dpr));
                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                drawGrid();
            }
            function drawGrid() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!gridOn) return;
                ctx.globalAlpha = 0.15;
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, canvas.height); ctx.stroke(); }
                for (let y = 0; y < canvas.height; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(canvas.width, y + 0.5); ctx.stroke(); }
                ctx.globalAlpha = 1;
            }
            window.toggleGrid = function () {
                if (!canvas) return;
                gridOn = !gridOn;
                canvas.style.display = gridOn ? 'block' : 'none';
                if (gridOn) { sizeGrid(); drawGrid(); }
            };
            window.addEventListener('resize', sizeGrid);
            if ('ResizeObserver' in window && wrap) {
                const ro = new ResizeObserver(sizeGrid);
                ro.observe(wrap);
            }
            // init
            if (canvas) { canvas.style.display = 'none'; sizeGrid(); }

            // --- FLOATING ALIGN TOOLBAR ---
            const tb = document.getElementById('top-toolbar');
            if (tb && wrap && tb.parentElement !== wrap) wrap.appendChild(tb);

            function positionToolbarFromDOM() {
                if (!tb || !wrap) return;
                // Only show when at least 2 selected boxes exist
                const sel = Array.from(document.querySelectorAll('#pagewrap .box.sel'));
                if (sel.length < 2) {
                    tb.style.display = 'none';
                    return;
                }

                // Compute union rect relative to wrap
                const wrapRect = wrap.getBoundingClientRect();
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                sel.forEach(node => {
                    const r = node.getBoundingClientRect();
                    minX = Math.min(minX, r.left - wrapRect.left);
                    minY = Math.min(minY, r.top - wrapRect.top);
                    maxX = Math.max(maxX, r.right - wrapRect.left);
                    maxY = Math.max(maxY, r.bottom - wrapRect.top);
                });

                tb.style.display = 'flex';

                // Place centered above with clamp
                const tbRect = tb.getBoundingClientRect();
                let left = minX + (maxX - minX) / 2 - tbRect.width / 2;
                let top = minY - tbRect.height - 8; // 8px margin

                // Clamp position to stay within the page wrap
                left = Math.max(0, Math.min(left, wrapRect.width - tbRect.width));
                top = Math.max(0, Math.min(top, wrapRect.height - tbRect.height));

                tb.style.position = 'absolute';
                tb.style.left = left + 'px';
                tb.style.top = top + 'px';
                // Important: Reset transform used by old logic
                tb.style.transform = 'none';
            }

            // Hook selection changes by observing class changes on boxes
            const selObserver = new MutationObserver(() => positionToolbarFromDOM());
            if (wrap) {
                selObserver.observe(wrap, { attributes: true, subtree: true, attributeFilter: ['class'] });
            }

            // Also hook known functions that change selection
            if (typeof window.updateSelectionActions === 'function') {
                const oldUpdate = window.updateSelectionActions;
                window.updateSelectionActions = function (...args) {
                    oldUpdate.apply(this, args);
                    positionToolbarFromDOM();
                };
            }
            if (typeof window.redraw === 'function') {
                const oldRedraw = window.redraw;
                window.redraw = function (...args) {
                    oldRedraw.apply(this, args);
                    positionToolbarFromDOM();
                };
            }

            window.addEventListener('resize', positionToolbarFromDOM);
            // First layout settle
            setTimeout(positionToolbarFromDOM, 50);
        })();
    </script>
</body>
</html>